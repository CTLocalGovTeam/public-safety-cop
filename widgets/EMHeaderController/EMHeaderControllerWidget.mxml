<?xml version="1.0" encoding="utf-8"?>
<!--
 | Version 10.1.1
 | Copyright 2012 Esri
 |
 | Licensed under the Apache License, Version 2.0 (the "License");
 | you may not use this file except in compliance with the License.
 | You may obtain a copy of the License at
 |
 |    http://www.apache.org/licenses/LICENSE-2.0
 |
 | Unless required by applicable law or agreed to in writing, software
 | distributed under the License is distributed on an "AS IS" BASIS,
 | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 | See the License for the specific language governing permissions and
 | limitations under the License.
-->
<viewer:BaseWidget xmlns:fx="http://ns.adobe.com/mxml/2009"
				   xmlns:s="library://ns.adobe.com/flex/spark"
				   xmlns:mx="library://ns.adobe.com/flex/mx"
				   xmlns:viewer="com.esri.viewer.*"
				   xmlns:HeaderController="widgets.EMHeaderController.*"
				   xmlns:components="com.esri.viewer.components.*"
				   width="100%"
				   borderSkin="{null}"
				   creationComplete="creationCompleteHandler(event)"
				   widgetConfigLoaded="widgetConfigLoadedHandler()" xmlns:esri="http://www.esri.com/2008/ags"
				   >
	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		@namespace mx "library://ns.adobe.com/flex/mx";
		@namespace viewer "com.esri.viewer.*";
		@namespace HeaderController "widgets.EMHeaderController.*";
		@namespace components "com.esri.viewer.components.*";

		.myclass {

			cornerradius:8;
		}


	</fx:Style>

	<fx:Script>
		<![CDATA[
			import com.esri.ags.geometry.Geometry;
			import com.esri.ags.geometry.MapPoint;
			import com.esri.ags.layers.GraphicsLayer;
			import com.esri.ags.layers.Layer;
			import com.esri.ags.symbols.PictureMarkerSymbol;
			import com.esri.ags.symbols.SimpleMarkerSymbol;
			import com.esri.ags.symbols.Symbol;
			import com.esri.ags.tasks.FindTask;
			import com.esri.ags.tasks.JSONTask;
			import com.esri.ags.tasks.supportClasses.AddressToLocationsParameters;
			import com.esri.ags.tasks.supportClasses.FindParameters;
			import com.esri.viewer.AppEvent;
			import com.esri.viewer.ViewerContainer;
			import com.esri.viewer.WidgetStates;
			import com.esri.viewer.components.HTMLPopup;
			import com.esri.viewer.components.HTMLPopupManager;
			import com.esri.viewer.utils.ErrorMessageUtil;
			import com.esri.viewer.utils.QueryString;

			import mx.collections.ArrayCollection;
			import mx.collections.ItemResponder;
			import mx.controls.Alert;
			import mx.controls.List;
			import mx.controls.TextArea;
			import mx.controls.TextInput;
			import mx.core.FlexGlobals;
			import mx.events.CloseEvent;
			import mx.events.FlexEvent;
			import mx.events.ListEvent;
			import mx.events.ValidationResultEvent;
			import mx.rpc.AsyncResponder;
			import mx.rpc.Fault;
			import mx.utils.StringUtil;

			import spark.components.supportClasses.ItemRenderer;

			import widgets.EMHeaderController.SplashUtils.Component.SplashComponent;
			import widgets.EMHeaderController.SplashUtils.utils.DataParserUtils;



			private var aboutContent:String;
			private var useSingleLine:Boolean = true;
			private var useProxy:Boolean;
			private var aboutButtonLabel:String = "";
			private var excludeFields:Array;
			private var graphicsLayer:GraphicsLayer;
			private var aboutWidth:Number;
			private var aboutHeight:Number;
			[Bindable]
			private var labelText:String = "";
			[Bindable]
			private var labelVisible:String = "";
			public var stateArray:ArrayCollection;
			private var textInput1:MyTextInput= new MyTextInput();
			private var Address_list:List= new List();
			private var locatorService:JSONTask;
			private var resultSymbol:Symbol;
			private var serviceWKID:Number;
			private var zoomScale:Number = 10000;
			private var minscore:Number;
			[Bindable]
			private var widgetItemArrCol:ArrayCollection;
			private var findTask:FindTask = new FindTask();
			private var addrObjects:Array = [];
			[Bindable]
			private var groupWidgetArrCol:ArrayCollection;
			private var listData:Boolean=true;
			[Bindable]
			private var title:String;
			private var locateResultAC:ArrayCollection;
			private var geocodeflag:String
			private var findTaskFlag:String;
			private var findUrl:String;
			private var layerIds:Array=new Array();
			private var searchIds:Array=new Array();
			private var layerNames:Array= new Array();
			private var isgeochecked:Boolean=false;
			private var searchField:Array= new Array();
			private var infoPopupFields:Array= new Array();
			private var gecodingResultLen:Number=0;
			private var findTaskResulringLen:Number=0;
			private var findUrls:Array= new Array();
			private var layerhashTb:ArrayCollection= new ArrayCollection();

			/* Splash widget */
			public var _dataParser:DataParserUtils= DataParserUtils.getInstance();
			private var txtareaWidth:Number;
			private var txtareaHeight:Number;
			private var serchTextLab:String='';

			private function creationCompleteHandler(event:FlexEvent):void
			{
				if (configData)
				{
					/*  configureGraphicsLayer();  */
					// if an explicit font size is specified, auto shrinking will not happen
					bannerTitle.autoShrinking = configData.titleFont.size == 0
					bannerSubtitle.autoShrinking = configData.subTitleFont.size == 0;

					widgetItemArrCol = getWidgetItems(configData.widgets);
					var uiList:Array = configData.viewerUI;

					for (var i:int = 0; i < uiList.length; i++)
					{
						if (uiList[i].id == "title")
						{
							bannerTitle.text = uiList[i].value;
						} // default is no title at all

						if (uiList[i].id == "subtitle")
						{
							bannerSubtitle.text = uiList[i].value;
						} // default is no subtitle at all

						if (uiList[i].id == "logo")
						{
							logoIcon.source = uiList[i].value;
						} // default is no logo at all
					}




					/*------------------------------------*/

					AppEvent.addListener(AppEvent.SET_LOGO, setLogoHandler);
					AppEvent.addListener(AppEvent.SET_TITLES, setTitlesHandler);
					AppEvent.addListener(AppEvent.WIDGET_STATE_CHANGED, widgetStateChangedHandler);

					textInput.restrict="A-Z0-9a-z, ";
					if(serchTextLab!='')
						textInput.text=serchTextLab;
					else
						textInput.text="Enter Address";

					//textInput.addEventListener(KeyboardEvent.KEY_UP,validateAddress);
					textInput.addEventListener(FocusEvent.FOCUS_IN,onFocusInHandler)
					textInput.addEventListener(FocusEvent.FOCUS_OUT,onFocusOutHandler)
					//search_input.addChild(textInput);
					_image.addEventListener(MouseEvent.CLICK,validateAddress);
					textInput.addEventListener(KeyboardEvent.KEY_UP,checkList);
					Address_list.visible=false;
					Address_list.width=textInput.width;
					search_input.addChild(Address_list);



				}


			}

			private function onFocusInHandler(event:FocusEvent):void
			{
				if(textInput.text==serchTextLab)
					textInput.text="";
			}
			private function onFocusOutHandler(event:FocusEvent):void
			{
				this.stage.focus=null;
				if(textInput.text=="")
					textInput.text=serchTextLab;

				//Address_list.visible=false;

			}

			private function checkList(event:KeyboardEvent):void
			{
				if(textInput.text=="")
					Address_list.visible=false;
			}



			private function setLogoHandler(event:AppEvent):void
			{
				logoIcon.source = event.data;
			}

			private function setTitlesHandler(event:AppEvent):void
			{
				bannerTitle.text = event.data.title;
				bannerSubtitle.text = event.data.subtitle;
			}

			private function onSubTitleUpdateComplete(event:FlexEvent):void
			{
				bannerSubtitle.visible = bannerSubtitle.text != "";
				bannerSubtitle.includeInLayout = bannerSubtitle.text != "";
				titleGroup.invalidateDisplayList();
				titleGroup.validateNow();
			}


			private function widgetConfigLoadedHandler():void
			{
				if (configXML)
				{
					var queryStringFromUrl:String =ExternalInterface.call("window.location.search.substring", 1);
					if (queryStringFromUrl)
					{
						trace(queryStringFromUrl);
						//Alert.show(queryStringFromUrl);
						var params:Array = queryStringFromUrl.split('&');
						//Alert.show(params.toString());
						var arr:Array=map.layerIds;
						var layerNames:Array= new Array();
						var eventnames:Array;
						var eventArr:Array=new Array();
						var count:Number= new Number();

						if(params.length>1)
						{
							eventArr = (params[1] as String).substring(2).split(',');


						}
						for (var i1:int=0;i1<arr.length;i1++)
						{
							eventnames= new Array();
							eventnames=(arr[i1] as String).substring(0).split('_');
							//Alert.show(eventnames[0]);
							for(var j:int=0;j<eventArr.length;j++ ){
							if(eventnames[0]==eventArr[j]){
								count++;
								var layerobj:Layer= map.getLayer(arr[i1]) as Layer
								var	visblelayer:String=(arr[i1] as String);
									map.getLayer(visblelayer).visible=true;
								//Alert.show(eventArr[j]);

							}

							}

							//layerNames.push(eventnames);

						}


					}

					aboutContent = configXML.about.content || "";
					labelText = configXML.about.label || getDefaultString("aboutLabel");
					labelVisible = configXML.about.visible.toString() || "true";
					aboutButtonLabel = configXML.about.btnlabel || getDefaultString("okLabel");
					aboutWidth = configXML.about.width || 500;
					aboutHeight = configXML.about.height || 500;
					configureGraphicsLayer();
					excludeFields = [];
					var fields:XMLList = configXML.excludefield as XMLList;
					for (var i:int = 0; i < fields.length(); i++)
					{
						excludeFields.push(fields[i].toString());
					}
					if (Number(configXML.zoomscale) > 0)
					{
						zoomScale = Number(configXML.zoomscale);
					}

					minscore = Number(configXML.minscore) || 40;

					configureLocator();
					serchTextLab=configXML.searchTextLabel.toString();

					if(serchTextLab !='')
						textInput.text=serchTextLab;
					else
						serchTextLab='Enter Address';

					geocodeflag=configXML.geocoding.@enable;
					findTaskFlag=configXML.searchlayers.@enable;
					//findUrls=configXML.searchlayers.searchlayer.@url.toString();
					layerIds=configXML.searchlayers.searchlayer.layerids.toString().split(",");
					//searchIds=configXML.searchlayers.searchlayer.toString().split(",");
					searchField=configXML.searchlayers.searchlayer.searchfields.toString().split(",");
					infoPopupFields=configXML.searchlayers.searchlayer.infopopupfields.toString().split(",");

					var objLayer:Object;
					if(configXML.searchlayers.length()>0)
					{
						for each(var layerInfo:XML in configXML.searchlayers.searchlayer)
						{

							objLayer= new Object();
							objLayer.layerNames=layerInfo.layername.toString();
							objLayer.layerids=layerInfo.layerids.toString().split(",")
							objLayer.layerUrl=	layerInfo.url.toString();
							objLayer.searchFields=layerInfo.searchfields.toString();
							/* objLayer.infopopupFields=layerInfo.infopopupfields.toString(); */
							var str:String=layerInfo.layername.toString()
							layerhashTb.addItem(objLayer);

						}
					}


					/** Splash Widget
					 */

					txtareaWidth = configXML.splashwidth ;
					txtareaHeight = configXML.splashheight ;

					_dataParser.widgetTitle=configXML.splashtitle;
					_dataParser.saveBtnLabel=configXML.savebtnlabel;
					_dataParser.eventGroupTitle=configXML.eventtitle;

					var esfRoleList:XMLList= configXML..esfrole;
					var obj:Object;
					for each (var esfRole:XML in esfRoleList)
					{
						obj=new Object();
						//obj.efsno = esfRole.@esfno[0];
						obj.efsname =esfRole.@esfname[0].toString();
						obj.imgsrc=esfRole.@imagesrc[0].toString();;
						obj.configFileName =esfRole.@configfile[0].toString();;
						_dataParser.esfRolesArr.addItem(obj);
					}
					var eventList:XMLList= configXML..event;
					var eventObjs:Object;
					for each (var events:XML in eventList)
					{
						eventObjs= new Object();
						eventObjs.eventName=events.@name[0].toString();
						eventObjs.eventId=events.@id[0].toString();
						_dataParser.eventArr.push(eventObjs);
					}
					var qs:QueryString = new QueryString();
					_dataParser.windowsUrl = qs._queryString;//ExternalInterface.call("function(){ return window.location.href;}");
					/** Old Code for splash screen*/

					/*HTMLPopup.show(content, btnLabel, txtareaWidth, txtareaHeight);
					*/



				}
				else
				{
					Alert.show('Config not found');
				}
			}

			//Changes
			private function prepareResultSymbol():void
			{
				const resultSymbolURL:String = configXML.symbols.picturemarkersymbol.@url || widgetIcon;
				const resultSymbolHeight:Number = configXML.symbols.picturemarkersymbol.@height || 30;
				const resultSymbolWidth:Number = configXML.symbols.picturemarkersymbol.@width || 30;
				const resultSymbolXOffset:Number = configXML.symbols.picturemarkersymbol.@xoffset || 0;
				const resultSymbolYOffset:Number = configXML.symbols.picturemarkersymbol.@yoffset || 0;
				resultSymbol = new PictureMarkerSymbol(resultSymbolURL, resultSymbolWidth, resultSymbolHeight, resultSymbolXOffset, resultSymbolYOffset);
			}

			private function configureGraphicsLayer():void
			{
				graphicsLayer = new GraphicsLayer();
				//graphicsLayer.name = configXML.layername || widgetTitle;
				//graphicsLayer.symbol = resultSymbol;
				//graphicsLayer.addEventListener(FlexEvent.HIDE, graphicsLayer_hideHandler);
				map.addLayer(graphicsLayer);
			}

			private function graphicsLayer_hideHandler(event:FlexEvent):void
			{
				hideInfoWindow();
			}

			private function hideInfoWindow():void
			{

				map.infoWindow.hide();

			}


			private function configureLocator():void
			{
				var locatorType:String = configXML.geocoding.locator;


				if (configXML.usesingleline.length() > 0)
				{
					useSingleLine = configXML.usesingleline == "true";
				}

				if (configXML.useproxy.length() > 0)
				{
					useProxy = configXML.useproxy == "true";
				}

				if (configXML.geocoding.locator.@wkid[0])
				{
					// for 9.X servers that are missing the SR in the metadata
					serviceWKID = Number(configXML.geocoding.locator.@wkid[0]);
				}

				var url:String = configXML.geocoding.locator;
				locatorService = new JSONTask();
				locatorService.url = url;
				locator.url = url;

				if (useProxy && configData.proxyUrl)
				{
					locatorService.proxyURL = configData.proxyUrl;
					locator.proxyURL = configData.proxyUrl;
				}

				var urlVars:URLVariables = new URLVariables();
				urlVars.f = "json";

				locatorService.execute(urlVars, new AsyncResponder(locatorService_resultHandler, locatorService_faultHandler));

			}
			private function configuretask():void
			{


			}


			private function locatorService_resultHandler(addressFieldData:Object, token:Object = null):void
			{
				createSingleLineAddressField(addressFieldData);
				if (addressFieldData.spatialReference && !isNaN(addressFieldData.spatialReference.wkid))
				{
					serviceWKID = addressFieldData.spatialReference.wkid;
				}
			}
			private function locatorService_faultHandler(fault:Fault, token:Object = null):void
			{
				var msg:String = "Unable to connect to Locator Service:\n"
					+ locator.url + "\n\n"
					+ "Most likely cause:\n"
					+ ErrorMessageUtil.getKnownErrorCauseMessage(fault) + "\n\n"
					+ "Details:\n"
					+ makeHTMLSafe(fault.toString());
				showError(msg);
			}

			private function makeHTMLSafe(content:String):String
			{
				content = content.replace(/>/g, "&gt;");
				content = content.replace(/</g, "&lt;");
				return content;
			}

			private function createSingleLineAddressField(singleLineAddressData:Object):void
			{
				textInput.id = singleLineAddressData.singleLineAddressField.name;
				addrObjects.push({ item: textInput, required: singleLineAddressData.singleLineAddressField.required });
			}

			private var vResult:ValidationResultEvent;
			private function frmLocateAddress_formKeyDownHandler(event:KeyboardEvent):void
			{
				if(event.keyCode== Keyboard.ENTER)
				{

					if(StringUtil.trim(textInput.text) == '')
					{
						Alert.show('Invaild input,please enter valid value','Error');
						Address_list.visible=false;
					}

					else
					{
						Address_list.visible=false;
						locateAddress(event);
					}
				}

			}
			private function validateAddress(event:Event):void
			{

				if(StringUtil.trim(textInput.text) == '')
				{
					Alert.show('Please enter the address','Error');
				}

				else
				{
					Address_list.visible=false;
					locateAddress(event);
				}

			}
			private var counter:Number=0;
			private var findTaskcheck:Boolean=false;
			private function locateAddress(event:Event):void
			{
				Address_list.visible=false;
				cursorManager.setBusyCursor();
				listData=true;
				map.infoWindow.hide();
				//graphicsLayer.clear();

				if(geocodeflag=='true')
				{
					isgeochecked=true;

					if (locateResultAC)
					{
						locateResultAC.removeAll();
					}

					var data:Object = new Object();
					var requiredFieldEmpty:Boolean;
					var emptyRequiredFieldNames:Array = [];
					for (var i:int = 0; i < addrObjects.length; i++)
					{
						var name:String = addrObjects[i].item.id;
						var value:String;
						if (addrObjects[i].item is TextInput)
						{
							var txtInput:TextInput = addrObjects[i].item as TextInput;
							if (addrObjects[i].required && txtInput.text == "")
							{
								requiredFieldEmpty = true;
								emptyRequiredFieldNames.push(txtInput.id);
							}
							else
							{
								value = txtInput.text;
							}
						}
						data[name] = value;
						var params:AddressToLocationsParameters = new AddressToLocationsParameters();
						params.address=data;
					}
					locator.addressToLocations(params, new ItemResponder(locateResult, locateError));
				} else
				{
					listData=false;
					isgeochecked=true;
				}
				if(findTaskFlag=='true'){

					var obj:Object;
					counter=0;
					Address_list.dataProvider = null;
					for(var i1:Number = 0; i1<layerhashTb.length; i1++)
					{

						obj=layerhashTb.getItemAt(i1);
						findTask.url=obj.layerUrl;
						var token:Object= new Object();
						token.layername=obj.layerNames;
						//findTask.addEventListener(FindEvent.EXECUTE_COMPLETE, executeCompleteHandler);
						var findParams:FindParameters= new FindParameters();
						findParams.contains=true;
						findParams.layerIds =obj.layerids;
						//findParams.searchFields=obj.searchFields;

						findParams.searchText=textInput.text;
						findParams.outSpatialReference=map.spatialReference;
						findParams.returnGeometry=true;
						findTask.execute(findParams,new AsyncResponder(executeCompleteHandler,onFault,token));

						function executeCompleteHandler(result:Object, token:Object = null):void
						{

							cursorManager.removeBusyCursor();
							var arrycoll:ArrayCollection= new ArrayCollection;
							//findTaskResulringLen=findTask.executeLastResult.length;
							counter++;
							if (findTask.executeLastResult.length > 0)
							{


								arrycoll.addItem(findTask.executeLastResult);

								//graphicsLayer.clear();
								for(var i:int=0;i<arrycoll.source.length;i++)
									Address_list.dataProvider=arrycoll.source[i];

								Address_list.labelField="value";
								Address_list.addEventListener(ListEvent.ITEM_CLICK,showTaskLocation);
								Address_list.visible=true;
								Address_list.rowCount=6;
								if(findTask.executeLastResult.length<Address_list.rowCount)
								{
									Address_list.rowCount=findTask.executeLastResult.length;
								}
								else
								{
									Address_list.rowCount=6;
								}
								Address_list.showDataTips=true;
								Address_list.dataTipFunction=myDataTipFunction1;
							}
							else
							{


								if((counter==layerhashTb.length ) && (isgeochecked==true || geocodeflag=="false") && listData==false){

									if(Address_list.dataProvider.length == 0 && isgeochecked==true){

										Alert.show("Cannot find address","Error");

									}
								}

							}

						}
					}



					Address_list.removeEventListener(ListEvent.ITEM_CLICK,showTaskLocation);

				}

			}
			public function myDataTipFunction(value:Object):String
			{
				return (value.address);
			}
			public function myDataTipFunction1(value:Object):String
			{
				return (value.value);
			}
			private function onFault(error:Fault, token:Object = null):void
			{
				counter++;
			}


			private function locateResult(data:Array, token:Object = null):void
			{
				isgeochecked=true;
				gecodingResultLen=data.length ;
				if (data.length > 0)
				{
					cursorManager.removeBusyCursor();
					listData=true;


					Address_list.labelField="address";
					Address_list.dataProvider=data;
					Address_list.visible= true;
					Address_list.rowCount=6;
					Address_list.addEventListener(ListEvent.ITEM_CLICK,showLocation);
					if(data.length<Address_list.rowCount)
					{
						Address_list.rowCount=data.length;
					}
					else
					{
						Address_list.rowCount=6;
					}
					Address_list.showDataTips=true;
					Address_list.dataTipFunction=myDataTipFunction;
				}
				else
				{
					listData=false;

					Address_list.removeEventListener(ListEvent.ITEM_CLICK,showLocation);
					cursorManager.removeBusyCursor();

					if(gecodingResultLen == 0 && findTaskFlag=="false"){

						Alert.show("Cannot find address","Error");
					}
				}


			}
			private function clearGrapich(event:Event):void
			{
				graphicsLayer.clear();
			}
			private function showLocation(event:Event):void
			{
				//hideInfoWindow();
				var str:String=(event.currentTarget.selectedItem as Object).address;
				textInput.text=str;
				map.infoWindow.label="";
				var datanew:Object=event.currentTarget.selectedItem as Object;
				//graphicsLayer.clear();

				Address_list.visible= false;



				var ptGraphic:com.esri.ags.Graphic = new com.esri.ags.Graphic(datanew.location as MapPoint,new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_DIAMOND, 22, 0x009933));
				graphicsLayer.add(ptGraphic)

				/* var popUpInfo:PopUpInfo = new PopUpInfo();
				popUpInfo.title = datanew.address;
				popUpInfo.description = datanew.score; */

				if (map.scale > zoomScale)
				{
					map.scale = zoomScale;
				}
				map.centerAt(datanew.location as MapPoint);
				const htmlText:String = datanew.address;
				const textArea:TextArea = new TextArea();
				textArea.width = 100;
				textArea.height = 60;
				textArea.editable=false;
				textArea.htmlText = htmlText;
				map.infoWindow.content = textArea;
				map.infoWindow.addEventListener(Event.CLOSE,clearGrapich);

				map.infoWindow.show(datanew.location as MapPoint)


				/* infoWindowShow();   */
			}
			/* private function createLocateResults(data:Array):void
			{
			var result:ArrayCollection = new ArrayCollection();
			var mapWKID:Number = map.spatialReference ? map.spatialReference.wkid : NaN;
			var mapIsWebMercator:Boolean = mapWKID == 102100 || mapWKID == 3857 || mapWKID == 102113;

			for each (var addrCandidate:AddressCandidate in data)
			{
			if (addrCandidate.score >= minscore)
			{
			var locateResult:LocateResult = new LocateResult();

			locateResult.title = addrCandidate.address ? String(addrCandidate.address) : widgetTitle;
			locateResult.content = getDefaultString("resultScoreText") + " " + (addrCandidate.score % 1 == 0 ? addrCandidate.score : addrCandidate.score.toFixed(1));
			locateResult.point = addrCandidate.location;
			if (!locateResult.point.spatialReference && !isNaN(serviceWKID)) // AGS 9.X returns locations w/o a SR and doesn't support outSR
			{
			var serviceIsWebMercator:Boolean = serviceWKID == 102100 || serviceWKID == 3857 || serviceWKID == 102113;
			if (mapIsWebMercator && serviceWKID == 4326)
			{
			locateResult.point = WebMercatorUtil.geographicToWebMercator(locateResult.point) as MapPoint;
			}
			else if (serviceIsWebMercator && mapWKID == 4326)
			{
			locateResult.point = WebMercatorUtil.webMercatorToGeographic(locateResult.point) as MapPoint;
			}
			}
			locateResult.link = "";
			locateResult.selected = false;

			result.addItem(locateResult);




			}
			}
			Address_list.labelField="address";
			Address_list.dataProvider=data;
			Address_list.visible= true;
			return result;
			}*/

			/* private function executeCompleteHandler(event:FindEvent):void
			{


			findTaskResulringLen=findTask.executeLastResult.length;
			if (findTask.executeLastResult.length > 0)
			{
			listData=true;
			//graphicsLayer.clear();
			Address_list.labelField="value";
			Address_list.dataProvider=findTask.executeLastResult;
			Address_list.addEventListener(ListEvent.ITEM_CLICK,showTaskLocation);
			Address_list.visible=true;
			Address_list.rowCount=6;
			if(findTask.executeLastResult.length<Address_list.rowCount)
			{
			Address_list.rowCount=findTask.executeLastResult.length;
			}
			else
			{
			Address_list.rowCount=6;
			}
			Address_list.showDataTips=true;
			Address_list.dataTipFunction=myDataTipFunction1;
			}
			else
			{
			Address_list.removeEventListener(ListEvent.ITEM_CLICK,showTaskLocation);
			if(findTaskResulringLen==0 && isgeochecked==true && gecodingResultLen==0){
			Alert.show("Could Not Found Address","Error");
			}

			}


			} */
			/* var graphic:com.esri.ags.Graphic;

			var resultCount:int = event.findResults.length;


			var smsFind:SimpleMarkerSymbol=  new SimpleMarkerSymbol();
			smsFind.alpha=configXML.findtask.symbols.markersymbol.@alpha;
			smsFind.color=configXML.findtask.symbols.markersymbol.@color;
			smsFind.style=configXML.findtask.symbols.markersymbol.@style;


			var slsFind:SimpleLineSymbol= new SimpleLineSymbol();
			slsFind.alpha=configXML.findtask.symbols.linesymbol.@alpha;
			slsFind.color=configXML.findtask.symbols.linesymbol.@color;
			slsFind.style=configXML.findtask.symbols.linesymbol.@style;


			var sfsFind:SimpleLineSymbol= new SimpleLineSymbol();
			sfsFind.alpha=configXML.findtask.symbols.linesymbol.@alpha;
			sfsFind.color=configXML.findtask.symbols.linesymbol.@color;
			sfsFind.style=configXML.findtask.symbols.linesymbol.@style;




			for (var i:Number = 0; i < resultCount; i++)
			{
			graphic = event.findResults[i].feature;
			graphic.toolTip = event.findResults[i].foundFieldName + ": " + event.findResults[i].value;

			switch (graphic.geometry.type)
			{
			case Geometry.MAPPOINT:
			{
			graphic.symbol = smsFind;
			break;
			}
			case Geometry.POLYLINE:
			{
			graphic.symbol = slsFind;
			break;
			}
			case Geometry.POLYGON:
			{
			graphic.symbol = sfsFind;
			break;
			}
			}

			graphicsLayer.add(graphic); */
			/* } */

			private function showTaskLocation(event:Event):void
			{
				var datanew:Object=event.currentTarget.selectedItem as Object;
				var str:String=(event.currentTarget.selectedItem as Object).value;
				textInput.text=str;
				Address_list.visible=false;
				var smsFind:SimpleMarkerSymbol=  new SimpleMarkerSymbol();
				smsFind.alpha=configXML.searchlayers.resultsymbols.markersymbol.@alpha;
				smsFind.color=configXML.searchlayers.resultsymbols.markersymbol.@color;
				smsFind.style=configXML.searchlayers.resultsymbols.markersymbol.@style;



				var slsFind:SimpleLineSymbol= new SimpleLineSymbol();
				slsFind.alpha=configXML.searchlayers.resultsymbols.linesymbol.@alpha;
				slsFind.color=configXML.searchlayers.resultsymbols.linesymbol.@color;
				slsFind.style=configXML.searchlayers.resultsymbols.linesymbol.@style;


				var sfsFind:SimpleFillSymbol= new SimpleFillSymbol();
				sfsFind.alpha=configXML.searchlayers.resultsymbols.fillsymbol.@alpha;
				sfsFind.color=configXML.searchlayers.resultsymbols.fillsymbol.@color;
				sfsFind.style=configXML.searchlayers.resultsymbols.fillsymbol.@style;

				var graphic:com.esri.ags.Graphic = new com.esri.ags.Graphic();
				graphic.geometry=datanew.feature.geometry as Geometry;
				var pt:MapPoint= new MapPoint();
				switch (datanew.feature.geometry.type)
				{
					case Geometry.MAPPOINT:
					{
						pt=datanew.feature.geometry;
						graphic.symbol =  smsFind;
						break;
					}
					case Geometry.POLYLINE:
					{
						pt=(datanew.feature.geometry as Geometry).extent.center as MapPoint
						graphic.symbol = slsFind;
						break;
					}
					case Geometry.POLYGON:
					{
						pt=(datanew.feature.geometry as Geometry).extent.center as MapPoint
						graphic.symbol = sfsFind;
						break;
					}
				}



				if (map.scale > zoomScale)
				{
					map.scale = zoomScale;
				}


				const htmlText:String ="Layer Name :" + datanew.layerName + "\n"+ "Field Name :"+ datanew.foundFieldName;
				const textArea:TextArea = new TextArea();
				textArea.percentWidth = 100;
				textArea.percentHeight =100;
				textArea.editable=false;
				textArea.htmlText = htmlText;

				map.infoWindow.content = textArea;
				map.infoWindow.label=datanew.value;
				map.infoWindow.addEventListener(Event.CLOSE,clearGrapich);


				map.centerAt(pt);
				map.infoWindow.show(pt);
				graphicsLayer.add(graphic);
			}
			private function locateError(info:Object, token:Object = null):void
			{
				/* showMessage(info.toString(), false); */
			}

			private function getWidgetItems(widgetList:Array):ArrayCollection
			{
				var menuItems:ArrayCollection= new ArrayCollection;
				var widgetItem:WidgetItem;
				for (var i:int = 0; i < widgetList.length; )
				{
					if (widgetList[i].grouped)
					{
						// grouped
						var widgetArray:Array = [];
						var length:Number = widgetList[i].groupLength;
						for (var k:int = 0; k < length; k++)
						{
							widgetArray.push({ widget: widgetList[i + k], open: (widgetList[i].preload && (widgetList[i].preload == "open" || widgetList[i].preload == "minimized")) ? true : false });
						}
						widgetItem = new WidgetItem;
						widgetItem.isGroup = true;
						widgetItem.label = widgetList[i].groupLabel;
						widgetItem.icon = widgetList[i].groupIcon;
						widgetItem.widgets = widgetArray;

						menuItems.addItem(widgetItem);
						// move to the next group
						i = i + length;
					}
					else
					{
						// upgrouped
						widgetItem = new WidgetItem;
						widgetItem.id = widgetList[i].id;
						widgetItem.label = widgetList[i].label;
						widgetItem.icon = widgetList[i].icon;
						widgetItem.url = widgetList[i].url;
						widgetItem.open = widgetList[i].preload && (widgetList[i].preload == "open" || widgetList[i].preload == "minimized");

						menuItems.addItem(widgetItem);

						// move to the next individual widget
						i++;
					}
				}

				return menuItems;
			}

			private function showAbout():void
			{
				this.stage.focus=null;

				createSplashScreen("","OK",txtareaWidth,txtareaHeight);
				//HTMLPopup.show(aboutContent, aboutButtonLabel, aboutWidth, aboutHeight,true,closeAbout);
			}

			private function closeAbout(event:CloseEvent):void{
				this.stage.focus=null;
			}
			private function widgetItemDG_widgetItemClickHandler(event:Event):void
			{
				this.stage.focus=null;
				var widgetItem:WidgetItem = ItemRenderer(event.target).data as WidgetItem;
				if (widgetItem.isGroup)
				{
					groupWidgetArrCol = new ArrayCollection();
					// check the array of widgets if they are open before hand
					for each (var widgetObj:Object in widgetItem.widgets)
					{
						var widgetItem1:WidgetItem = new WidgetItem;
						widgetItem1.id = widgetObj.widget.id;
						widgetItem1.label = widgetObj.widget.label;
						widgetItem1.icon = widgetObj.widget.icon;
						widgetItem1.url = widgetObj.widget.url;
						widgetItem1.open = widgetObj.open;

						groupWidgetArrCol.addItem(widgetItem1);
					}
					menuToolTip.visible = false;
					widgetList.visible = true;
				}
				else
				{
					AppEvent.dispatch(AppEvent.WIDGET_RUN, widgetItem.id);
				}
			}

			private function widgetList_widgetItemClickHandler(event:Event):void
			{
				this.stage.focus=null;
				var widgetItem:WidgetItem = ItemRenderer(event.target).data as WidgetItem;
				AppEvent.dispatch(AppEvent.WIDGET_RUN, widgetItem.id);
			}

			[Bindable]
			private var xOver:int;

			private function widgetItemDG_widgetItemMouseOverHandler(event:Event):void
			{
				var pointGlobal:Point = ItemRenderer(event.target).localToGlobal(new Point(0, 0));
				var pointLocal:Point = headerGroup.globalToLocal(pointGlobal); // get the local coordinates where the menuItem will be shown

				xOver = pointLocal.x;

				widgetList.visible = false;
				if (WidgetItem(ItemRenderer(event.target).data).label)
				{
					menuToolTip.visible = true;
					menuTitle.text = WidgetItem(ItemRenderer(event.target).data).label;
				}
			}

			private function widgetItemDG_widgetItemMouseOutHandler(event:Event):void
			{
				menuToolTip.visible = false;
			}

			private function widgetStateChangedHandler(event:AppEvent):void
			{
				var data:Object = event.data;
				for (var i:Number = 0; i < widgetItemArrCol.length;)
				{
					if (widgetItemArrCol.getItemAt(i).isGroup)
					{
						// make sure to check it for the array of widgets(group) if they are open before hand
						var widgetFound:Boolean;
						for each (var widgetObj:Object in widgetItemArrCol.getItemAt(i).widgets)
						{
							if (data.id as Number == widgetObj.widget.id)
							{
								widgetFound = true;
								widgetObj.open = (data.state as String == WidgetStates.WIDGET_OPENED) || (data.state as String == WidgetStates.WIDGET_MINIMIZED);
								break;
							}
						}
						if (widgetFound)
						{
							break;
						}
						else
						{
							i++;
						}
					}
					else
					{
						if (data.id as Number == widgetItemArrCol.getItemAt(i).id)
						{
							widgetItemArrCol.getItemAt(i).open = (data.state as String == WidgetStates.WIDGET_OPENED) || (data.state as String == WidgetStates.WIDGET_MINIMIZED);
							break;
						}
						else
						{
							i++;
						}
					}
				}
				// check for any grouped widgets
				if (groupWidgetArrCol && groupWidgetArrCol.length > 0)
				{
					for (var j:Number = 0; j < groupWidgetArrCol.length;)
					{
						if (data.id as Number == groupWidgetArrCol.getItemAt(j).id)
						{
							groupWidgetArrCol.getItemAt(j).open = (data.state as String == WidgetStates.WIDGET_OPENED) || (data.state as String == WidgetStates.WIDGET_MINIMIZED);
							widgetList.visible = false;
							break;
						}
						else
						{
							j++;
						}
					}
				}
			}

			private function widgetList_rollOutHandler(event:MouseEvent):void
			{
				widgetList.visible = false;
			}

			/*****
			 * Splash Widget Code starting
			 *
			 *
			 * **/

			public static function createSplashScreen(content:String = "",
													  btnLabel:String = "OK",
													  width:Number = 500,
													  height:Number = 100,
													  modal:Boolean = true,
													  closeHandler:Function = null):void
			{

				var splashScreen:SplashComponent= new SplashComponent();
				var parent:Sprite = Sprite(FlexGlobals.topLevelApplication);

				if (closeHandler != null)
				{
					splashScreen.CloseBtn.addEventListener(CloseEvent.CLOSE, closeHandler);
					splashScreen.CancelBtn.addEventListener(CloseEvent.CLOSE, closeHandler);
				}


				splashScreen.txtareaWidth = width;
				splashScreen.txtareaHeight = height;

				HTMLPopupManager.addPopUp(splashScreen, parent, modal);


			}

			private function close(event:Event):void
			{
				HTMLPopupManager.removePopUp(this);
				dispatchEvent(new CloseEvent(CloseEvent.CLOSE));
			}


		]]>
	</fx:Script>
	<fx:Declarations>
		<esri:Locator id="locator"
					  outSpatialReference="{map.spatialReference}"
					  url="http://tasks.arcgisonline.com/ArcGIS/rest/services/Locators/TA_Streets_US_10/GeocodeServer"/>
		<esri:SimpleLineSymbol id="slsFind1"
							   width="3"
							   alpha="0.9"
							   color="0xFFFF00"
							   style="solid"/>

		<!-- Symbol for Find Result as Point -->
		<esri:SimpleMarkerSymbol id="smsFind1"
								 alpha="0.9"
								 color="0xFFFF00"

								 style="square">
			<esri:SimpleLineSymbol color="0x000000"/>
		</esri:SimpleMarkerSymbol>

		<!-- Symbol for Find Result as Polygon -->
		<esri:SimpleFillSymbol id="sfsFind1"
							   alpha="0.7"
							   color="0xFFFF00"/>
		<mx:StringValidator id="address_CityValidator"
							property="text"
							minLength="2" />


	</fx:Declarations>


	<s:Group id="headerGroup"
			 width="100%" height="85"  >


		<s:Group id="headerContent"
				 width="100%" height="{headerGroup.height - 45}">
			<s:Rect width="100%" height="100%"
					alpha="{getStyle('contentBackgroundAlpha')}">
				<s:fill>
					<s:SolidColor color="{getStyle('contentBackgroundColor')}"/>
				</s:fill>
			</s:Rect>
			<s:HGroup width="100%" height="100%"
					  gap="2"
					  paddingLeft="2" paddingTop="2"
					  verticalAlign="contentJustify" >
				<mx:Image id="logoIcon"
						  horizontalAlign="left"
						  maxHeight="{headerContent.height}"
						  maxWidth="80" top="2"
						  verticalAlign="top" />
				<s:VGroup id="titleGroup"
						  height="{headerContent.height}"
						  gap="0"
						  verticalAlign="top" >
					<components:AutoFontLabel id="bannerTitle"
											  maxWidth="300"
											  styleName="BannerTitle"/>
					<components:AutoFontLabel id="bannerSubtitle"
											  maxWidth="300"
											  styleName="BannerSubtitle"
											  updateComplete="onSubTitleUpdateComplete(event)"/>
				</s:VGroup>

				<s:HGroup id="widgetBox" paddingTop="5"
						  width="70%" verticalAlign="top"
						  horizontalAlign="center" >
					<HeaderController:WidgetItemDataGroup id="widgetItemDG"
														  dataProvider="{widgetItemArrCol}"
														  widgetItemClick="widgetItemDG_widgetItemClickHandler(event)"
														  widgetItemMouseOut="widgetItemDG_widgetItemMouseOutHandler(event)"
														  widgetItemMouseOver="widgetItemDG_widgetItemMouseOverHandler(event)">
						<HeaderController:layout>
							<s:HorizontalLayout gap="12"
												useVirtualLayout="true"
												verticalAlign="middle"/>
						</HeaderController:layout>
					</HeaderController:WidgetItemDataGroup>


				</s:HGroup>
				<s:HGroup id="searchBox"
						  width="18%" paddingTop="5"
						  horizontalAlign="left">
					<mx:VBox id="search_input" keyDown="frmLocateAddress_formKeyDownHandler(event)">
						<mx:Canvas width="100%" id="searchcanvas">
							<mx:TextInput id="textInput"
										  height="25"
										  paddingTop="2"
										  paddingRight="{_image.width+10}"
										  width="230"
										  fontSize="12"
										  fontFamily="Arial" borderVisible="true"

										  borderStyle="solid"
										  />
							<mx:Image id="_image"  buttonMode="true" x="{textInput.width - _image.width}" y="{textInput.height - _image.height}"  source="@Embed(source='assets/images/locate.png')" toolTip="Search" />
						</mx:Canvas>
					</mx:VBox>
				</s:HGroup>

				<s:HGroup id="linkBox" paddingTop="15"
						  horizontalAlign="left"  width="4%"
						  verticalAlign="top" >

					<s:Label buttonMode="true" paddingLeft="5"
							 click="showAbout()"
							 styleName="BannerSubtitle"
							 text="{labelText}"
							 useHandCursor="true"
							 paddingBottom="10"
							 toolTip="{labelText}"
							 verticalAlign="middle"
							 visible="{labelVisible == 'true'}"/>
				</s:HGroup>
			</s:HGroup>
		</s:Group>
		<s:VGroup id="menuToolTip"
				  x="{xOver + 12 - menuToolTipBox.width/2}" y="{headerContent.height}"
				  gap="0"
				  horizontalAlign="center"
				  visible="false">
			<s:Graphic id="menuTriangle" visible="{menuToolTip.visible}">
				<s:Group>
					<s:Path data="m 7 0 l 7 14 l -14 0 z">
						<s:fill>
							<s:SolidColor alpha="1" color="{getStyle('contentBackgroundColor')}"/>
						</s:fill>
					</s:Path>
				</s:Group>
			</s:Graphic>
			<s:BorderContainer id="menuToolTipBox"
							   width="{menuTitle.width + 8}" height="{menuTitle.height +2}"
							   backgroundColor="{getStyle('contentBackgroundColor')}"
							   borderVisible="false"
							   cornerRadius="10"
							   visible="{menuToolTip.visible}">
				<s:layout>
					<s:HorizontalLayout horizontalAlign="center" verticalAlign="middle"/>
				</s:layout>
				<s:Label id="menuTitle"
						 paddingBottom="4"
						 paddingLeft="5"
						 paddingRight="5"
						 paddingTop="5"
						 visible="{menuToolTip.visible}"/>
			</s:BorderContainer>
		</s:VGroup>
		<s:BorderContainer id="widgetList"
						   x="{xOver + 4 - widgetListDG.width/2}" y="{headerContent.height}" width="{widgetListDG.width + 4}" height="{widgetListDG.height + 2}"
						   backgroundColor="{getStyle('contentBackgroundColor')}"
						   borderColor="{getStyle('color')}"
						   borderVisible="true"
						   cornerRadius="3"
						   rollOut="widgetList_rollOutHandler(event)"
						   visible="false">
			<HeaderController:WidgetListDataGroup id="widgetListDG"
												  width="150"
												  dataProvider="{groupWidgetArrCol}"
												  visible="{widgetList.visible}"
												  widgetListItemClick="widgetList_widgetItemClickHandler(event)">
				<HeaderController:layout>
					<s:VerticalLayout paddingTop="6"
									  useVirtualLayout="true"
									  verticalAlign="middle"/>
				</HeaderController:layout>
			</HeaderController:WidgetListDataGroup>
		</s:BorderContainer>

		<s:filters>
			<s:DropShadowFilter alpha="0.5"
								blurX="10"
								blurY="10"/>
		</s:filters>

	</s:Group>


</viewer:BaseWidget>
